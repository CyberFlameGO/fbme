
public class BacktraceService {
  private final Map<string, Set<string>> graph = new HashMap<string, Set<string>>();
  private final Set<string> visited = new HashSet<string>();
  private final MPSProject project;
  private final CompositeFBTypeDeclaration compositeFb;


  public BacktraceService(final MPSProject project, final CompositeFBTypeDeclaration compositeFb) {
    this.project = project;
    this.compositeFb = compositeFb;
  }

  public List<string> getRelatedItemSimpleNames(final SystemItemValue itemValue) {
    graph.clear();
    visited.clear();

    final SystemItem item = itemValue.getItem();
    switch (item.getType()) {
      case SystemItemType.EVENT_PORT :
        backtraceEvent(item.getFbName(), item.getItemName());
      case SystemItemType.DATA_PORT :
        backtraceData(item.getFbName(), item.getItemName());
      case SystemItemType.ECC :
        backtraceEccState(item.getItemName(), itemValue.getValue());

    }

    final Set<string> relatedItemSimpleNames = new HashSet<string>();
    relatedItemSimpleNames.addAll(graph.keySet());
    graph.values().forEach({final Set<string> set => relatedItemSimpleNames.addAll(set); });

    return new ArrayList<string>(relatedItemSimpleNames);
  }

  private void backtraceEvent(final string curFbName, final string event) {
    this.project.getModelAccess().runReadAction({ =>
      final FBNetwork fbNethwork = compositeFb.getNetwork();
      final list<FunctionBlockDeclaration> fbs = fbNethwork.getFunctionBlocks();
      final BasicFBTypeDeclaration curFb = (BasicFBTypeDeclaration) fbs.findFirst({~it => it.getName() :eq: curFbName; }).getTypeReference().getTarget();
      final Optional<EventDeclaration> inputEventOpt = curFb.getInputEvents().stream().filter({final EventDeclaration eventD => eventD.getName() :eq: event; }).findFirst();
      if (inputEventOpt.isPresent()) {
        final EventDeclaration inputEvent = inputEventOpt.get();
        fbNethwork.getEventConnections().stream().filter({FBNetworkConnection con =>
          final string target = ((EventDeclaration) con.getTargetReference().getTarget().getPortTarget()).getName();
          return target :eq: event;
        }).forEach({FBNetworkConnection con =>
          final string fbName = con.getSourceReference().getTarget().getFunctionBlock().getName();
          final string eventName = ((EventDeclaration) con.getSourceReference().getTarget().getPortTarget()).getName();
          final string fullName = fbName + "." + eventName;

          if (!visited.contains(fullName)) {
            visited.add(fullName);
            graph.putIfAbsent(fullName, new HashSet<string>());
            graph.get(fullName).add(curFbName + "." + event);
            backtraceEvent(fbName, eventName);
          }
        });
      }
    });
  }

  private void backtraceData(final string curFbName, final string var) {
    this.project.getModelAccess().runReadAction({ =>
      final FBNetwork fbNethwork = compositeFb.getNetwork();
      final list<FunctionBlockDeclaration> fbs = fbNethwork.getFunctionBlocks();
      final BasicFBTypeDeclaration curFb = (BasicFBTypeDeclaration) fbs.findFirst({~it => it.getName() :eq: curFbName; }).getTypeReference().getTarget();
      curFb.getAlgorithms().forEach({final AlgorithmDeclaration algorithm => ((AlgorithmBody.ST) algorithm.getBody()).getStatements().stream().forEach({final Statement statement =>
          if (statement instanceof AssignmentStatement) {
            final AssignmentStatement assignment = ((AssignmentStatement) statement);
            final Variable curVar = assignment.getVariable();
            if (curVar instanceof VariableReferenceByNode) {
              if (((VariableReferenceByNode) curVar).getReference().getTarget().getName() :eq: var) {
                curFb.getEcc().getStates().forEach({final StateDeclaration state =>
                  if (state.getActions().stream().filter({final StateAction action => action.getAlgorithm() :eq: algorithm; }).findAny().isPresent()) {
                    final string eccName = state.getName();
                    final string fullName = curFbName + "." + eccName;
                    if (!visited.contains(fullName)) {
                      visited.add(fullName);
                      graph.putIfAbsent(fullName, new HashSet<string>());
                      graph.get(fullName).add(curFbName + "." + eccName);
                      backtraceEccState(curFbName, eccName);
                    }
                  }
                });

              }
            }
          }
        }); });
    });
  }

  private void backtraceEccState(final string curFbName, final string state) {
    this.project.getModelAccess().runReadAction({ =>
      final FBNetwork fbNethwork = compositeFb.getNetwork();
      final list<FunctionBlockDeclaration> fbs = fbNethwork.getFunctionBlocks();
      final BasicFBTypeDeclaration curFb = (BasicFBTypeDeclaration) fbs.findFirst({~it => it.getName() :eq: curFbName; }).getTypeReference().getTarget();
      final List<StateTransition> transitions = curFb.getEcc().getTransitions();
      transitions.stream().filter({final StateTransition transition => transition.getTargetReference().getTarget().getName() :eq: state; }).forEach({final StateTransition transition =>
        final ECTransitionCondition condition = transition.getCondition();
        final string fbName = condition.getEventReference().getTarget().getFunctionBlock().getName();
        final string eventName = condition.getEventReference().getTarget().getPortTarget().getName();
        final string fullName = fbName + "." + eventName;
        if (!visited.contains(fullName)) {
          visited.add(fullName);
          graph.putIfAbsent(fullName, new HashSet<string>());
          graph.get(fullName).add(curFbName + "." + state);
          backtraceEvent(fbName, eventName);
        }
      });
    });
  }
}